

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>A Library for Peano Arithmetic &mdash; OCanren  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="The Range of a Fleet of Aircraft" href="../aircraft_fleet/README.html" />
    <link rel="prev" title="A Simple Data Base" href="../ascii_ctrl_db/README.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> OCanren
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../tuto_main.html">The Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../helloWorld/README.html">Say “Hello World!” in OCanren</a></li>
<li class="toctree-l2"><a class="reference internal" href="../digTypes/README.html">Digesting the Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ascii_ctrl_db/README.html">A Simple Data Base</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">A Library for Peano Arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#advanced-injection-functions">Advanced Injection Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reification-and-reifiers">Reification and Reifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overwriting-the-show-function">Overwriting the <em>show</em> Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relations-on-peano-numbers">Relations on Peano Numbers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scrutinizing-relations">Scrutinizing Relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analyzing-the-search-behaviour">Analyzing the Search Behaviour</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modifying-the-search-behaviour">Modifying the Search Behaviour</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-trick-of-generate-and-test">The Trick of Generate-and-test</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-formula-parser">The Formula Parser</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-a-library">Building a Library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../aircraft_fleet/README.html">The Range of a Fleet of Aircraft</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../camlp5.html">Camlp5 syntax extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PPX.html">Syntax extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../papers.html">Papers</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">OCanren</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../tuto_main.html">The Tutorial</a> &raquo;</li>
        
      <li>A Library for Peano Arithmetic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/JetBrains-Research/OCanren/blob/master/doc/tuto_main/peano/README.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="a-library-for-peano-arithmetic">
<h1>A Library for Peano Arithmetic<a class="headerlink" href="#a-library-for-peano-arithmetic" title="Permalink to this headline">¶</a></h1>
<p>We hope the reader will learn the following techniques   from this lesson:</p>
<ul class="simple">
<li><a class="reference external" href="#advanced-injection-functions">Advanced injection functions</a> Defining injection functions for value constructors of variant types, using the Fmap family of module functors <code class="docutils literal notranslate"><span class="pre">Fmap</span></code>, <code class="docutils literal notranslate"><span class="pre">Fmap2</span></code>, <code class="docutils literal notranslate"><span class="pre">Fmap3</span></code>, etc., which are provided by the module <a class="reference external" href="../../Installation/ocanren/src/core/Logic.mli">Logic</a>.</li>
<li><a class="reference external" href="#reification-and-reifiers">Reification and Reifiers</a> Defining reifiers to convert data from the injected level to the logic level, again with help from the Fmap family of module functors.</li>
<li><a class="reference external" href="#overwriting-the-show-function">Overwriting the show Function</a> Overwriting, or redefining the “show” function for values of a logic type, to allow for more concise and human readable printing of them.</li>
<li><a class="reference external" href="#relations-on-peano-numbers">Relations on Peano Numbers</a> Defining (possibly recursive) relations, e.g., comparison, addition and division on Peano numbers.</li>
<li><a class="reference external" href="#scrutinizing-relations">Scrutinizing Relations</a> Making queries to relations using combinations of unknown arguments.</li>
<li><a class="reference external" href="#analyzing-the-search-behaviour">Analyzing the search behaviour</a> Analyzing why a query returns certain answers.</li>
<li><a class="reference external" href="#modifying-the-search-behaviour">Modifying the search behaviour</a> Reordering the conjuncts within the body of a relation definition to modify the way in which the relation searches for answers in a given query.</li>
<li><a class="reference external" href="#the-trick-of-generate-and-test">The trick of generate and test</a> Programming a relation so that answers to certain queries are found by brute-force.</li>
<li><a class="reference external" href="#the-formula-parser">The formula parser</a> Observing that the implementation of the <code class="docutils literal notranslate"><span class="pre">ocanren</span> <span class="pre">{}</span></code> quotation takes care of the precedence, associativity and scope of the logic connectives, and replaces constructors of variant types by injection function names, and primitive values by their injected versions.</li>
<li><a class="reference external" href="#building-a-library">Building a library</a> Writing and testing a library in OCanren.</li>
</ul>
<p>The techniques are presented in detail in sections below, to which the
labels ( <strong>T.1</strong>, <strong>T.2</strong>, etc) are linked. Each section is
self-contained and could be read independent of other sections.</p>
<p>The library has a systematic test file, which can be compiled (and
linked) and executed by running the following shell commands in (your
local copy of) the lesson directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="o">&amp;&amp;</span> <span class="o">./</span><span class="n">peano</span><span class="o">.</span><span class="n">opt</span>
</pre></div>
</div>
<p>A copy of the result of the test is <a class="reference external" href="answers.txt">answers.txt</a> that
is obtained using the shell command <code class="docutils literal notranslate"><span class="pre">./peano.opt</span> <span class="pre">&gt;</span> <span class="pre">answers.txt</span></code>.</p>
<div class="section" id="advanced-injection-functions">
<h2>Advanced Injection Functions<a class="headerlink" href="#advanced-injection-functions" title="Permalink to this headline">¶</a></h2>
<p>The primary injection operator is <code class="docutils literal notranslate"><span class="pre">!!</span></code> which is used to cast primitive
values (such as characters and strings) and constant constructors of
variant types (particularly whose type constructors do not have a type
parameter) from the ground level to the injected level. For those
variant types whose type constructors have one or more type parameters,
the primitive injection operator is inadequate. We use instead <em>advanced
injection functions</em> to build injected values, which are defined using
distribution functions provided by the Fmap family of module functors
together with the injection helper <code class="docutils literal notranslate"><span class="pre">inj</span></code>, all from the module Logic.
In our Peano Arithmetic <a class="reference external" href="peano.ml">library implementation</a>, the
following block of code defines advanced injection functions <code class="docutils literal notranslate"><span class="pre">o</span></code> and
<code class="docutils literal notranslate"><span class="pre">s</span></code> for the abstract Peano number type <code class="docutils literal notranslate"><span class="pre">Ty.t</span></code>, which correspond
respectively to the value constructors <code class="docutils literal notranslate"><span class="pre">O</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code> :</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">struct</span>
  <span class="nd">@type</span> <span class="s1">&#39;a t = O | S of &#39;</span><span class="n">a</span> <span class="k">with</span> <span class="n">show</span><span class="p">,</span> <span class="n">gmap</span>
  <span class="n">let</span> <span class="n">fmap</span> <span class="o">=</span> <span class="n">fun</span> <span class="n">f</span> <span class="n">d</span> <span class="o">-&gt;</span> <span class="n">GT</span><span class="o">.</span><span class="n">gmap</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">f</span> <span class="n">d</span>
<span class="n">end</span><span class="p">;;</span>

<span class="n">include</span> <span class="n">Ty</span>
<span class="n">module</span> <span class="n">F</span> <span class="o">=</span> <span class="n">Fmap</span><span class="p">(</span><span class="n">Ty</span><span class="p">)</span>

<span class="n">let</span> <span class="n">o</span> <span class="p">()</span> <span class="o">=</span> <span class="n">inj</span> <span class="o">@@</span> <span class="n">F</span><span class="o">.</span><span class="n">distrib</span> <span class="n">O</span>
<span class="n">let</span> <span class="n">s</span> <span class="n">n</span> <span class="o">=</span> <span class="n">inj</span> <span class="o">@@</span> <span class="n">F</span><span class="o">.</span><span class="n">distrib</span> <span class="p">(</span><span class="n">S</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>The general workflow of defining advanced injection functions is as
follows:</p>
<ol class="arabic simple">
<li>We begin with a variant type whose type constructor <code class="docutils literal notranslate"><span class="pre">t</span></code> has one or
more type parameters. This is always an OCanren abstract type, such
as the abstract Peano number type or the abstract list type.</li>
<li>We count the number of type parameters of the type constructor in
order to choose the suitable module functor from the Fmap family: for
one type parameter, use <code class="docutils literal notranslate"><span class="pre">Fmap</span></code> ; for two type parameters, use
<code class="docutils literal notranslate"><span class="pre">Fmap2</span></code>; three type parameters, <code class="docutils literal notranslate"><span class="pre">Fmap3</span></code> and so on.</li>
<li>We request the <code class="docutils literal notranslate"><span class="pre">gmap</span></code> plugin for the type constructor, and use it
to define a function named <code class="docutils literal notranslate"><span class="pre">fmap</span></code> simply by renaming.</li>
<li>We put the definitions of the type constructor <code class="docutils literal notranslate"><span class="pre">t</span></code> and the <code class="docutils literal notranslate"><span class="pre">fmap</span></code> function in one module, and suppy that module as a parameter to the chosen Fmap family module functor. The result is a module <code class="docutils literal notranslate"><span class="pre">F</span></code> with
three functions one of which is <code class="docutils literal notranslate"><span class="pre">distrib</span></code>, the distribution
function.</li>
<li>For each value constructor of the type <code class="docutils literal notranslate"><span class="pre">t</span></code>, we define a function
whose name is the same as the value constructor except that the
initial letter is set to lower case. For example, <code class="docutils literal notranslate"><span class="pre">Cons</span></code>, <code class="docutils literal notranslate"><span class="pre">S</span></code> and
<code class="docutils literal notranslate"><span class="pre">NUL</span></code> become respectively <code class="docutils literal notranslate"><span class="pre">cons</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">nUL</span></code>.</li>
</ol>
<ul>
<li><p class="first">For each value constructor <code class="docutils literal notranslate"><span class="pre">Constr0</span></code> of no argument, define:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">constr0</span> <span class="o">=</span> <span class="n">fun</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Logic</span><span class="o">.</span><span class="n">inj</span> <span class="o">@@</span> <span class="n">F</span><span class="o">.</span><span class="n">distrib</span> <span class="n">Constr0</span>
</pre></div>
</div>
</li>
<li><p class="first">For each value constructor <code class="docutils literal notranslate"><span class="pre">Constr1</span></code> of one argument, define:</p>
<blockquote>
<div><div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">constr1</span> <span class="o">=</span> <span class="n">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">Logic</span><span class="o">.</span><span class="n">inj</span> <span class="o">@@</span> <span class="n">F</span><span class="o">.</span><span class="n">distrib</span> <span class="p">(</span><span class="n">Constr1</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">For each value constructor <code class="docutils literal notranslate"><span class="pre">Constru</span></code> of <em>u</em> (&gt; 1) arguments,  define:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">constru</span> <span class="o">=</span> <span class="n">fun</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xu</span> <span class="o">-&gt;</span> <span class="n">Logic</span><span class="o">.</span><span class="n">inj</span> <span class="o">@@</span> <span class="n">F</span><span class="o">.</span><span class="n">distrib</span> <span class="o">@@</span> <span class="n">Constru</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">xu</span><span class="p">)</span>
</pre></div>
</div>
<p>In the definition of a typical advanced injection function, the value
constructor takes arguments which are at the injected level, and the
combination of <code class="docutils literal notranslate"><span class="pre">inj</span></code> and <code class="docutils literal notranslate"><span class="pre">distrib</span></code> serves to inject the top level
value while preserving the structure of constructor application. If
we explain by a schematic where a pair of enclosing square brackets
<code class="docutils literal notranslate"><span class="pre">[]</span></code> signifies the injected status of the enclosed data, we would
say that:</p>
</li>
<li><p class="first">An advanced injection function <code class="docutils literal notranslate"><span class="pre">constr</span></code> converts a value of the
form <code class="docutils literal notranslate"><span class="pre">Constr</span> <span class="pre">([arg1],</span> <span class="pre">...,</span> <span class="pre">[argn])</span></code> to a value of the form
<code class="docutils literal notranslate"><span class="pre">[Constr</span> <span class="pre">(arg1,</span> <span class="pre">...,</span> <span class="pre">argn)]</span></code>. In other words,</p>
</li>
<li><p class="first">The injection function <code class="docutils literal notranslate"><span class="pre">constr</span></code> takes arguments
<code class="docutils literal notranslate"><span class="pre">[arg1],</span> <span class="pre">...,</span> <span class="pre">[argn]</span></code> and builds a value of the form
<code class="docutils literal notranslate"><span class="pre">[Constr</span> <span class="pre">(arg1,</span> <span class="pre">...,</span> <span class="pre">argn)]</span></code>.</p>
</li>
</ul>
<p>We advise the reader to find in the
<a class="reference external" href="../../Installation/ocanren/src/core/Logic.mli">interface</a> of the
Logic module the Fmap module functor family and the functors’ argument
types (which are module types): that would provide a more formal
explanation of what advanced injection functions do and why they are
defined in the given manner.</p>
</div>
<div class="section" id="reification-and-reifiers">
<h2>Reification and Reifiers<a class="headerlink" href="#reification-and-reifiers" title="Permalink to this headline">¶</a></h2>
<p>Say we have a logic variable <code class="docutils literal notranslate"><span class="pre">x</span></code> and a substitution
<code class="docutils literal notranslate"><span class="pre">[(x,</span> <span class="pre">Lam(z,y));</span> <span class="pre">(y,</span> <span class="pre">App(a,b))]</span></code> that associates <code class="docutils literal notranslate"><span class="pre">x</span></code> with the term
<code class="docutils literal notranslate"><span class="pre">Lam(z,y)</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> with <code class="docutils literal notranslate"><span class="pre">App(a,b)</span></code> where <code class="docutils literal notranslate"><span class="pre">y,</span> <span class="pre">z</span></code> are also logic
variables. We would like to know what <code class="docutils literal notranslate"><span class="pre">x</span></code> is with respect to the
substitution. It is straightforward to replace <code class="docutils literal notranslate"><span class="pre">x</span></code> by <code class="docutils literal notranslate"><span class="pre">Lam(z,y)</span></code> but
since <code class="docutils literal notranslate"><span class="pre">y</span></code> is associated with <code class="docutils literal notranslate"><span class="pre">App(a,b)</span></code> we can further replace <code class="docutils literal notranslate"><span class="pre">y</span></code>
in <code class="docutils literal notranslate"><span class="pre">Lam(z,y)</span></code>, and finally we get the term <code class="docutils literal notranslate"><span class="pre">Lam(z,App(a,b))</span></code> .
Although there is still an unbound part <code class="docutils literal notranslate"><span class="pre">z</span></code>, we have no further
information about how <code class="docutils literal notranslate"><span class="pre">z</span></code> might be instantiated, so we leave it there.
What we have done is called <em>reification</em> of the logic variable <code class="docutils literal notranslate"><span class="pre">x</span></code> :
we instantiate it as much as possible, but allowing unbound logic
variables to occur in the result. A <em>reifier</em> is a function that reifies
logic variables.</p>
<p>We know that there are primary and advanced injection functions.
Similarly there are primary and advanced reifiers: the primary reifier
<code class="docutils literal notranslate"><span class="pre">Logic.reify</span></code> reifies logic variables over base types (like character
and string) and simple variant types (i.e., those that have only
constant constructors). Advanced reifiers are for logic variables over
variant types whose type constructors have one or more type parameters
and there exist non-constant (value) constructors. The Peano Arithmetic
library defines an advanced reifier for the Peano number type:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">rec</span> <span class="n">reify</span> <span class="o">=</span> <span class="n">fun</span> <span class="n">env</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">reify</span> <span class="n">reify</span> <span class="n">env</span> <span class="n">n</span><span class="p">;;</span>
</pre></div>
</div>
<p>Advanced reifiers are defined using the Fmap module functor family. The
correct Fmap module functor for defining the reifier for a type is the
same as that selected for defining advanced injection functions for the
same type. The result of applying the correct Fmap module functor is a
module that provides, besides a distribution function, a reifier builder
named <code class="docutils literal notranslate"><span class="pre">reify</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">F.reify</span></code> in the case of our library. Note
there is an abuse of names: the name <code class="docutils literal notranslate"><span class="pre">reify</span></code> has been used for both
reifiers and reifier builders. If a type constructor takes other types
are parameters, then the reifier for the top level type is built from
reifiers for the parameter types: we build “larger” reifiers from
“smaller” reifiers. The Peano number reifier is recursive because the
Peano number type is recursive: the reader should refer to the
<a class="reference external" href="../../Installation/ocanren/src/core/Logic.mli#L136">signature</a> of
<code class="docutils literal notranslate"><span class="pre">F.reify</span></code> and see how the types of the reifier and the reifier builder
fit together.</p>
</div>
<div class="section" id="overwriting-the-show-function">
<h2>Overwriting the <em>show</em> Function<a class="headerlink" href="#overwriting-the-show-function" title="Permalink to this headline">¶</a></h2>
<p>The default <em>show</em> function for a variant type converts values of that
type to strings in a straightforward way, e.g., a logic Peano number
representation of the integer 1 would be converted to the string
<code class="docutils literal notranslate"><span class="pre">&quot;Value(S(Value</span> <span class="pre">O))&quot;</span></code> whilst “the successor of some unknown number”
could be <code class="docutils literal notranslate"><span class="pre">&quot;Value(S(Var(1,[])))&quot;</span></code>. These are not too readable.</p>
<p>The Logic module has already
<a class="reference external" href="../../Installation/ocanren/src/core/Logic.ml#L35">redefined</a> the
<em>show</em> function for the type <code class="docutils literal notranslate"><span class="pre">Logic.logic</span></code> so that the above values
would instead be converted to strings <code class="docutils literal notranslate"><span class="pre">&quot;S(O)&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;S(_.1)&quot;</span></code>
respectively, omitting the verbose constructors <code class="docutils literal notranslate"><span class="pre">Value</span></code> and <code class="docutils literal notranslate"><span class="pre">Var</span></code>
and displaying variables in the form <code class="docutils literal notranslate"><span class="pre">_.n</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the first
parameter of the constructor <code class="docutils literal notranslate"><span class="pre">Var</span></code>. The redefinition happens within
the record value <code class="docutils literal notranslate"><span class="pre">logic</span></code> which has a field <code class="docutils literal notranslate"><span class="pre">GT.plugins</span></code>. This record
value origins from the <code class="docutils literal notranslate"><span class="pre">&#64;type</span></code> definition of the type constructor
<code class="docutils literal notranslate"><span class="pre">Logic.logic</span></code> and is auto-generated by the GT package. The field
<code class="docutils literal notranslate"><span class="pre">GT.plugins</span></code> is an object with several methods, one of which is
<code class="docutils literal notranslate"><span class="pre">show</span></code> : other plugins (or methods) keep their default meanings but
<code class="docutils literal notranslate"><span class="pre">show</span></code> is redefined.</p>
<p>However, when there are too many repetitions of the constructor <code class="docutils literal notranslate"><span class="pre">S</span></code>,
the <em>show</em> function as redefined in the Logic module is no longer
suitable. Our Peano Arithmetic library therefore offers a further
customized <a class="reference external" href="peano.ml#L107">redefinition</a> just for displaying logic
Peano numbers, converting those values without free variables directly
to Arabic numbers and those with free variables a sum between an Arabic
number and the symbol <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>In like manner, the reader may: - Redefine the <em>show</em> function to behave
in other ways, or - Redefine other plugins by modifying the
<code class="docutils literal notranslate"><span class="pre">GT.plugins</span></code> field, or - Redefine plugins for other types.</p>
<p>Some additional remarks on the last point: the <code class="docutils literal notranslate"><span class="pre">&#64;type</span></code>
definition of a
type constructor <code class="docutils literal notranslate"><span class="pre">typeconstr-name</span></code> generates a record value also named
<code class="docutils literal notranslate"><span class="pre">typeconstr-name</span></code> of the type <code class="docutils literal notranslate"><span class="pre">GT.t</span></code>. This could be viewed by adding
the <code class="docutils literal notranslate"><span class="pre">-i</span></code> option as indicated in the <a class="reference external" href="Makefile#L10">Makefile</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BFLAGS</span> <span class="o">=</span> <span class="o">-</span><span class="n">rectypes</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">i</span>
</pre></div>
</div>
<p>See also the <a class="reference external" href="https://github.com/JetBrains-Research/GT/blob/039193385e6cb1a67bc8a9d00c662d9d1dc5478b/src/GT.ml4#L37">GT
source</a>.</p>
</div>
<div class="section" id="relations-on-peano-numbers">
<h2>Relations on Peano Numbers<a class="headerlink" href="#relations-on-peano-numbers" title="Permalink to this headline">¶</a></h2>
<p>This section teaches the reader how to read and write relation
definitions.</p>
<p>The reader is already familiar with reading and writing functions in
OCaml. To read a function, just look at the type annotation (if any) to
determine what are the input types and what is the output type, and then
inspect the function body to see how the inputs are processed to produce
the output. To write a function, first decide the type of the function,
and then design the internal procedure that produces the output from the
input.</p>
<p>In OCanren, a relation is a function only at the language implementation
level, and as users our experience with functions do not transfer well
when it comes to reading and writing relations. That’s why relational
programming claims the status of being a unique programming paradigm
distinct from imperative programming and functional programming. Working
with relations requires learning a new way of thinking: <em>declarative</em>
thinking.</p>
<p>Relation definitions are declarative, meaning that it first of all
states a proposition. The emphasize is on “what” rather than “how”. It
is the language implementation that takes care of “how”, but the user of
the language should foucs on “what”. For example, look at the addition
relation:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">rec</span> <span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span>
  <span class="n">ocanren</span><span class="p">{</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span>
         <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span>
           <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="n">S</span> <span class="n">m</span> <span class="o">&amp;</span> <span class="n">add</span> <span class="n">n</span> <span class="n">b</span> <span class="n">m</span><span class="p">}</span>
</pre></div>
</div>
<p>It says nothing about how to compute the sum <code class="docutils literal notranslate"><span class="pre">c</span></code> of two numbers <code class="docutils literal notranslate"><span class="pre">a</span></code>
and <code class="docutils literal notranslate"><span class="pre">b</span></code>, instead it only says what conditions must be satisfied so
that the addition relation exists among the three numbers <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>
and <code class="docutils literal notranslate"><span class="pre">c</span></code> — if <code class="docutils literal notranslate"><span class="pre">a</span></code> equals <code class="docutils literal notranslate"><span class="pre">O</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> equals <code class="docutils literal notranslate"><span class="pre">c</span></code>, or, if <code class="docutils literal notranslate"><span class="pre">a</span></code>
equals <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> equals <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">m</span></code> and the numbers <code class="docutils literal notranslate"><span class="pre">n,b,m</span></code> also
satisfy the addition relation, for some <code class="docutils literal notranslate"><span class="pre">n,m</span></code>. No other way is given
in which we can establish the addition relation among three numbers.</p>
<p>Another example is the “less than” relation:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">rec</span> <span class="n">lt</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="n">ocanren</span><span class="p">{</span> <span class="n">fresh</span> <span class="n">n</span> <span class="ow">in</span>
           <span class="n">b</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span> <span class="o">&amp;</span>
             <span class="p">{</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span>
             <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in</span>
               <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39;</span>
               <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39; n }}</span>
</pre></div>
</div>
<p>It says that <code class="docutils literal notranslate"><span class="pre">a</span></code> is less than <code class="docutils literal notranslate"><span class="pre">b</span></code> if there exist <code class="docutils literal notranslate"><span class="pre">n</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">b</span></code> equals <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span></code>, and either <code class="docutils literal notranslate"><span class="pre">a</span></code> equals <code class="docutils literal notranslate"><span class="pre">O</span></code> or there exist
<code class="docutils literal notranslate"><span class="pre">n'</span></code> such that <code class="docutils literal notranslate"><span class="pre">a</span></code> equals <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n'</span></code> and <code class="docutils literal notranslate"><span class="pre">n'</span></code> is less than <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>Other relations in the library shall be read in this way, and they are
all written with the declarative reading in mind. The reader is
encouraged to write a relation for subtraction: <code class="docutils literal notranslate"><span class="pre">sub</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> iff
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">c</span></code>, or, put in another way: iff <code class="docutils literal notranslate"><span class="pre">b</span></code> is <code class="docutils literal notranslate"><span class="pre">O</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> is
<code class="docutils literal notranslate"><span class="pre">c</span></code>, or <code class="docutils literal notranslate"><span class="pre">b</span></code> is <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> is <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n'</span></code> and <code class="docutils literal notranslate"><span class="pre">sub</span> <span class="pre">n'</span> <span class="pre">n</span> <span class="pre">c</span></code>.</p>
</div>
<div class="section" id="scrutinizing-relations">
<h2>Scrutinizing Relations<a class="headerlink" href="#scrutinizing-relations" title="Permalink to this headline">¶</a></h2>
<p>Taking the “less than” relation as an example, we can ask questions
like:</p>
<blockquote>
<div><ul class="simple">
<li>Is zero less than one ? Is one less than two ? Is one less than zero ? Is two less than one?</li>
<li>What is less than five ? Five is less than what ?</li>
<li>What is less than what ?</li>
</ul>
</div></blockquote>
<p>The first set of questions above is for <em>checking</em>: we provide concrete
numbers and ask if they satisfy the relation. The remaining two sets of
questions are for <em>searching</em>: looking for numbers that satisfy the
relation. Note that the questions are organized: there coud be no
unknown, one unknown or two unknowns, and each argument position of the
relation might be an unknown. In general, for a relation of N arguments,
the total number of kinds of questions we can ask is ( R is the number
of unknowns in NCR):</p>
<p>NC0 + NC1 + NC2 + … + NCN-1 + NCN</p>
<p>Running the <a class="reference external" href="test.ml#L53">test</a> shows that OCanren answers all the
questions well. For example, the goal:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fun</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">ocanren</span> <span class="p">{</span> <span class="n">lt</span> <span class="n">O</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">))</span> <span class="p">}</span>
</pre></div>
</div>
<p>asks about what is <code class="docutils literal notranslate"><span class="pre">q</span></code> so that zero is less than one and one is less
than two, and the answer is just a free variable <code class="docutils literal notranslate"><span class="pre">n</span></code> meaning that <code class="docutils literal notranslate"><span class="pre">q</span></code> could be any
number and the relation always holds between the given numbers. The
similar goal:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fun</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">ocanren</span> <span class="p">{</span> <span class="n">lt</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)</span> <span class="n">O</span> <span class="o">|</span> <span class="n">lt</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">))</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>asks about what is <code class="docutils literal notranslate"><span class="pre">q</span></code> so that one is less than zero or two is less
than one. There is no answer, meaning that there is no <code class="docutils literal notranslate"><span class="pre">q</span></code> to make the
relation hold between the given numbers.</p>
<p>The goal below asks what is less than five:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fun</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">ocanren</span> <span class="p">{</span> <span class="n">lt</span> <span class="n">q</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="p">}</span>
</pre></div>
</div>
<p>For this goal the answers <code class="docutils literal notranslate"><span class="pre">0,1,2,3,4</span></code> are found, which is quite
satisfactory.</p>
<p>The relations <code class="docutils literal notranslate"><span class="pre">lte,</span> <span class="pre">add,</span> <span class="pre">div,</span> <span class="pre">gcd</span></code> are also questioned systematically
in the test file.</p>
<p>Note that the addition relation can perform subtraction, and the
division relation can do multiplication. For instance, the goal below
asks “What adds 4 equals to 7 ?” and whose answer is “3”:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fun</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">ocanren</span> <span class="p">{</span> <span class="n">add</span> <span class="n">q</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">))))</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))))</span> <span class="p">}</span>
</pre></div>
</div>
<p>This amounts to performing the subtraction <code class="docutils literal notranslate"><span class="pre">7</span> <span class="pre">-</span> <span class="pre">4</span></code>. The next goal asks
“What divided by 5 equals 3 with remainder 0 ?” and the answer is “15”:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fun</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">ocanren</span> <span class="p">{</span> <span class="n">div</span> <span class="n">q</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span> <span class="n">O</span> <span class="p">}</span>
</pre></div>
</div>
<p>It amounts to the multiplication <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code>.</p>
</div>
<div class="section" id="analyzing-the-search-behaviour">
<h2>Analyzing the Search Behaviour<a class="headerlink" href="#analyzing-the-search-behaviour" title="Permalink to this headline">¶</a></h2>
<p>When asking the <code class="docutils literal notranslate"><span class="pre">lt</span></code> relation “what is less than 5” using the goal:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fun</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">ocanren</span> <span class="p">{</span> <span class="n">lt</span> <span class="n">q</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="p">}</span>                                  <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>OCanren returns 0,1,2,3,4. Let’s see why. It really is a matter of
definition: we defined <code class="docutils literal notranslate"><span class="pre">lt</span> <span class="pre">a</span> <span class="pre">b</span></code> to be a certain formula <code class="docutils literal notranslate"><span class="pre">(Eq.1)</span></code> and
now we substitute 5 for <code class="docutils literal notranslate"><span class="pre">b</span></code> in the formula <code class="docutils literal notranslate"><span class="pre">lt</span> <span class="pre">a</span> <span class="pre">b</span></code> followed by
several steps of simplification then we get a formula <code class="docutils literal notranslate"><span class="pre">(Eq.12)</span></code> that
literally says <code class="docutils literal notranslate"><span class="pre">a</span></code> shall be 0, 1, 2, 3 or 4. Below are the details.</p>
<p>We reproduce the definition of <code class="docutils literal notranslate"><span class="pre">lt</span></code> in the followinig simplified form:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fresh</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">b</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span>
       <span class="o">&amp;</span> <span class="p">{</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span> <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in a == S n&#39;</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39; n }</span>
                                                                             <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Now replace <code class="docutils literal notranslate"><span class="pre">b</span></code> by <code class="docutils literal notranslate"><span class="pre">(S(S(S(S(S</span> <span class="pre">O)))))</span></code> in <code class="docutils literal notranslate"><span class="pre">(Eq.1)</span></code>, we get:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="o">=</span> <span class="n">fresh</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span>
                         <span class="o">&amp;</span> <span class="p">{</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span> <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in a == S n&#39;</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39; n }</span>
                                                                 <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Replace <code class="docutils literal notranslate"><span class="pre">(S(S(S(S(S</span> <span class="pre">O)))))</span> <span class="pre">==</span> <span class="pre">S</span> <span class="pre">n</span></code> by <code class="docutils literal notranslate"><span class="pre">(S(S(S(S</span> <span class="pre">O))))</span> <span class="pre">==</span> <span class="pre">n</span></code> in
<code class="docutils literal notranslate"><span class="pre">(Eq.2)</span></code>, we get:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="o">=</span> <span class="n">fresh</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">))))</span> <span class="o">==</span> <span class="n">n</span>
                         <span class="o">&amp;</span> <span class="p">{</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span> <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in a == S n&#39;</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39; n }</span>
                                                                 <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">(Eq.3)</span></code>, remove <code class="docutils literal notranslate"><span class="pre">fresh</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">(S(S(S(S</span> <span class="pre">O))))</span> <span class="pre">==</span> <span class="pre">n</span></code>, then replace
all free occurences of <code class="docutils literal notranslate"><span class="pre">n</span></code> by <code class="docutils literal notranslate"><span class="pre">(S(S(S(S</span> <span class="pre">O))))</span></code>. The top level <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>
and the braces are no longer needed, so also being removed. We get:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="o">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span>
                       <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in a == S n&#39;</span>
                 <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39; (S(S(S(S O))))                              (Eq.4)</span>
</pre></div>
</div>
<p>From <code class="docutils literal notranslate"><span class="pre">(Eq.1)</span></code> to <code class="docutils literal notranslate"><span class="pre">(Eq.4)</span></code> what we have done is to provide a concrete
value (the Peano number 5) as the second argument of <code class="docutils literal notranslate"><span class="pre">lt</span></code> and use the
result of unification to simplify the equation. The recursive call of
<code class="docutils literal notranslate"><span class="pre">lt</span></code> in the right hand side of <code class="docutils literal notranslate"><span class="pre">(Eq.4)</span></code> can be treated similarly: we
provide a concrete value (the Peano number 4) as the second argument of
<code class="docutils literal notranslate"><span class="pre">lt</span></code> <code class="docutils literal notranslate"><span class="pre">(Eq.5)</span></code> and use the result of unification to simplify the
equation <code class="docutils literal notranslate"><span class="pre">(Eq.6)</span></code>, which is then used to substitute for the recursive
call of <code class="docutils literal notranslate"><span class="pre">lt</span></code> in <code class="docutils literal notranslate"><span class="pre">(Eq.4)</span></code>, as follows.</p>
<p>Replace <code class="docutils literal notranslate"><span class="pre">b</span></code> by <code class="docutils literal notranslate"><span class="pre">(S(S(S(S</span> <span class="pre">O))))</span></code> and<code class="docutils literal notranslate"><span class="pre">a</span></code> by <code class="docutils literal notranslate"><span class="pre">n'</span></code> in <code class="docutils literal notranslate"><span class="pre">(Eq.1)</span></code>
in a capture-avoiding manner, we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">n</span><span class="s1">&#39; (S(S(S(S O)))) = fresh n in (S(S(S(S O)))) == S n</span>
                       <span class="o">&amp;</span> <span class="p">{</span> <span class="n">n</span><span class="s1">&#39; == O | fresh n&#39;&#39; in n&#39;</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="n">n</span> <span class="p">}</span>
                                                                     <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Using the result of unification we can simplify <code class="docutils literal notranslate"><span class="pre">(Eq.5)</span></code> into:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">n</span><span class="s1">&#39; (S(S(S(S O)))) = n&#39;</span> <span class="o">==</span> <span class="n">O</span>
                     <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">n</span><span class="s1">&#39; == S n&#39;&#39;</span>
                     <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span>                      <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>Now in <code class="docutils literal notranslate"><span class="pre">(Eq.4)</span></code> replace <code class="docutils literal notranslate"><span class="pre">lt</span> <span class="pre">n'</span> <span class="pre">(S(S(S(S</span> <span class="pre">O))))</span></code> by the right hand
side of <code class="docutils literal notranslate"><span class="pre">(Eq.6)</span></code>:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="o">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span>
                       <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in a == S n&#39;</span>
                       <span class="o">&amp;</span> <span class="p">{</span> <span class="n">n</span><span class="s1">&#39; == O</span>
                         <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">n</span><span class="s1">&#39; == S n&#39;&#39;</span>
                           <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span> <span class="p">}</span>           <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>The right hand side of <code class="docutils literal notranslate"><span class="pre">(Eq.7)</span></code>
produces another value of <code class="docutils literal notranslate"><span class="pre">a</span></code> which
is <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">O</span></code>, as follows. In <code class="docutils literal notranslate"><span class="pre">(Eq.7)</span></code>, distribute <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">S</span> <span class="pre">n'</span></code> we get:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="o">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span>
                       <span class="o">|</span> <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in</span>
                           <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39; &amp;  n&#39;</span> <span class="o">==</span> <span class="n">O</span>
                         <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39; &amp; fresh n&#39;&#39; in n&#39;</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span>

                                                     <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Replace <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">S</span> <span class="pre">n'</span> <span class="pre">&amp;</span>&#160; <span class="pre">n'</span> <span class="pre">==</span> <span class="pre">O</span></code> by <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">S</span> <span class="pre">O</span></code> in <code class="docutils literal notranslate"><span class="pre">(Eq.8)</span></code>, we get:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="o">=</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">O</span>
                       <span class="o">|</span>  <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in</span>
                            <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">O</span>
                          <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39; &amp; fresh n&#39;&#39; in  n&#39;</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span>

                                                                             <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>In the right hand side of <code class="docutils literal notranslate"><span class="pre">(Eq.9)</span></code> move <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">S</span> <span class="pre">O</span></code> out of the scope
of the <code class="docutils literal notranslate"><span class="pre">fresh</span> <span class="pre">n'</span> <span class="pre">in</span></code>, we have:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span> <span class="o">=</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">O</span>
                       <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">O</span>
                       <span class="o">|</span>  <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in</span>
                          <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39; &amp; fresh n&#39;&#39; in n&#39;</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span>

                                                                             <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>From <code class="docutils literal notranslate"><span class="pre">(Eq.1)</span></code> to <code class="docutils literal notranslate"><span class="pre">(Eq.10)</span></code> are steps of substitution, unification
and simplification. Recursive calls are expanded and then reduced, and
the initial formula <code class="docutils literal notranslate"><span class="pre">lt</span> <span class="pre">a</span> <span class="pre">(S(S(S(S(S</span> <span class="pre">O)))))</span></code> is gradually unfolded so
that values of <code class="docutils literal notranslate"><span class="pre">a</span></code> are revealed one by one. Continue this way, the
last but one equation would be:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span>  <span class="o">=</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">O</span>
                        <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">O</span>
                        <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)</span>
                        <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">))</span>
                        <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span>
                        <span class="o">|</span>  <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39; in a == S n&#39;</span>
                        <span class="o">&amp;</span>  <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">n</span><span class="s1">&#39; == S n&#39;&#39;</span>
                        <span class="o">&amp;</span>  <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39;&#39;&#39; in n&#39;&#39; == S n&#39;&#39;&#39;</span>
                        <span class="o">&amp;</span>  <span class="n">fresh</span> <span class="n">n</span><span class="s1">&#39;&#39;&#39;&#39; in n&#39;&#39;&#39;</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span><span class="s1">&#39;&#39;&#39;&#39;</span>
<span class="s1">                        &amp;  fresh n&#39;&#39;&#39;&#39;&#39;</span> <span class="ow">in</span> <span class="n">n</span><span class="s1">&#39;&#39;&#39;&#39; == S n&#39;&#39;&#39;&#39;&#39;</span> <span class="o">&amp;</span> <span class="n">lt</span> <span class="n">n</span><span class="s1">&#39;&#39;&#39;&#39;&#39; O</span>
<span class="s1">                                                                 (Eq.11)</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">lt</span> <span class="pre">n'''''</span> <span class="pre">O</span></code> expands to <code class="docutils literal notranslate"><span class="pre">fresh</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">O</span> <span class="pre">==</span> <span class="pre">S</span> <span class="pre">n</span> <span class="pre">&amp;</span> <span class="pre">...</span></code> which
is false, therefore the last equation is:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lt</span> <span class="n">a</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))))</span>  <span class="o">=</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">O</span>
                        <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">O</span>
                        <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)</span>
                        <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">))</span>
                        <span class="o">|</span>  <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span>                               <span class="p">(</span><span class="n">Eq</span><span class="o">.</span><span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
<p>From <code class="docutils literal notranslate"><span class="pre">(Eq.12)</span></code> we read off the answers to the query.</p>
<p>The derivation from <code class="docutils literal notranslate"><span class="pre">(Eq.1)</span></code> to <code class="docutils literal notranslate"><span class="pre">(Eq.12)</span></code>, combined with the
operational semantics of OCanren in terms of stream manipulation,
explains why we get the answer that <code class="docutils literal notranslate"><span class="pre">a</span></code> equals 0,1,2,3 or 4 from the
goal <code class="docutils literal notranslate"><span class="pre">(G.1)</span></code>.</p>
<p>The reader may take an exercise to show that one plus one equals two by
simplifying the formula <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">(S</span> <span class="pre">O)</span> <span class="pre">(S</span> <span class="pre">O)</span> <span class="pre">c</span></code>.</p>
</div>
<div class="section" id="modifying-the-search-behaviour">
<h2>Modifying the Search Behaviour<a class="headerlink" href="#modifying-the-search-behaviour" title="Permalink to this headline">¶</a></h2>
<p>We compare two versions of the <em>simplify</em> relation, differing from each
other only by a swap of conjuncts.</p>
<p>Both versions share the logic that the simplest form of <code class="docutils literal notranslate"><span class="pre">a/b</span></code> is
<code class="docutils literal notranslate"><span class="pre">a'/b'</span></code> where <code class="docutils literal notranslate"><span class="pre">a'</span></code> (<code class="docutils literal notranslate"><span class="pre">b'</span></code>) is <code class="docutils literal notranslate"><span class="pre">a</span></code> (resp. <code class="docutils literal notranslate"><span class="pre">b</span></code>) divided by the
greatest common divisor of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, provided <code class="docutils literal notranslate"><span class="pre">b</span></code> is non-zero.
There is a short cut for the case where <code class="docutils literal notranslate"><span class="pre">a</span></code> is zero, then <code class="docutils literal notranslate"><span class="pre">b'</span></code> is
set to one directly.</p>
<p>The difference is that:</p>
<ul class="simple">
<li>In one version we say, “<cite>a</cite> (<cite>b</cite>) divided by <cite>c</cite> equals <cite>a’</cite> (resp. <cite>b’</cite>), and <cite>c</cite> is the gcd of <cite>a</cite> and <cite>b</cite>.”</li>
<li>In the other version we say, “<cite>c</cite> is the gcd of <cite>a</cite> and <cite>b</cite>, and <cite>a</cite> (<cite>b</cite>) divided by <cite>c</cite> equals <cite>a’</cite> (resp. <cite>b’</cite>).”</li>
</ul>
<p>In OCanren:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">simplify</span> <span class="n">a</span> <span class="n">b</span> <span class="n">a</span><span class="s1">&#39; b&#39;</span> <span class="o">=</span>
  <span class="n">ocanren</span> <span class="p">{</span>  <span class="n">fresh</span> <span class="n">n</span> <span class="ow">in</span>
    <span class="n">b</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span> <span class="o">&amp;</span>
    <span class="p">{</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span> <span class="o">&amp;</span> <span class="n">a</span><span class="s1">&#39; == O &amp; b&#39;</span> <span class="o">==</span> <span class="n">S</span> <span class="n">O</span>
    <span class="o">|</span> <span class="n">fresh</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span>
        <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">m</span>
      <span class="o">&amp;</span> <span class="n">div</span> <span class="n">a</span> <span class="n">c</span> <span class="n">a</span><span class="s1">&#39; O             (* div first, then gcd *)</span>
      <span class="o">&amp;</span> <span class="n">div</span> <span class="n">b</span> <span class="n">c</span> <span class="sa">b</span><span class="s1">&#39; O</span>
      <span class="o">&amp;</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="p">}</span> <span class="p">}</span>

<span class="n">let</span> <span class="n">simplify</span><span class="s1">&#39; a b a&#39;</span> <span class="sa">b</span><span class="s1">&#39; =</span>
  <span class="n">ocanren</span> <span class="p">{</span> <span class="n">fresh</span> <span class="n">n</span> <span class="ow">in</span>
     <span class="n">b</span> <span class="o">==</span> <span class="n">S</span> <span class="n">n</span> <span class="o">&amp;</span>
     <span class="p">{</span> <span class="n">a</span> <span class="o">==</span> <span class="n">O</span> <span class="o">&amp;</span> <span class="n">a</span><span class="s1">&#39; == O &amp; b&#39;</span> <span class="o">==</span> <span class="n">S</span> <span class="n">O</span>
     <span class="o">|</span> <span class="n">fresh</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span>
         <span class="n">a</span> <span class="o">==</span> <span class="n">S</span> <span class="n">m</span>
       <span class="o">&amp;</span> <span class="n">gcd</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>                <span class="p">(</span><span class="o">*</span> <span class="n">gcd</span> <span class="n">first</span><span class="p">,</span> <span class="n">then</span> <span class="n">div</span> <span class="o">*</span><span class="p">)</span>
       <span class="o">&amp;</span> <span class="n">div</span> <span class="n">a</span> <span class="n">c</span> <span class="n">a</span><span class="s1">&#39; O</span>
       <span class="o">&amp;</span> <span class="n">div</span> <span class="n">b</span> <span class="n">c</span> <span class="sa">b</span><span class="s1">&#39; O  } }</span>
</pre></div>
</div>
<p>The test file offers a <a class="reference external" href="test.ml#L199">comparison</a> of these two
versions over their forward and backward search behaviours. By <em>forward
search</em> we mean that given a ratio <em>a/b</em> find its simplest form, e.g.,
18/12 is simplified to 3/2. By <em>backward search</em> we mean given a ratio
in the simplest form, find its equal ratios, e.g., 3/2 could be
simplified from 6/4, 9/6, 12/8, etc. The test shows that both versions
work well for forward search, but when it comes to backward search,
<code class="docutils literal notranslate"><span class="pre">simplify</span></code> returns answers quickly but <code class="docutils literal notranslate"><span class="pre">simplify'</span></code> took ages without
returning anything.</p>
<p>The ordering of the conjuncts, together with the state of the logic
varaibles and the search behaviour of the sub-relations, results in
apparently different operational meaning of the conjunctions in backward
search, as follows:</p>
<ol class="arabic simple">
<li><em>Variant 1</em></li>
</ol>
<blockquote>
<div><div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>div a c a’ O &amp;
div b c b’ O &amp;
gcd a b c
</pre></div>
</div>
<p>Find <cite>a</cite> and <cite>c</cite> such  that <code class="docutils literal notranslate"><span class="pre">a</span></code> divided by <cite>c</cite> equals <cite>a’</cite> exactly. Then find <code class="docutils literal notranslate"><span class="pre">b</span></code> such that  <code class="docutils literal notranslate"><span class="pre">b</span></code> divided by <cite>c</cite>
equals <cite>b’</cite> exactly. Now check that the gcd of <cite>a</cite> and <cite>b</cite> is <cite>c</cite>.</p>
<p>Before the execution of the first conjunct, both <cite>a</cite> and <cite>c</cite> are unknowns. When the second conjunct is to be executed, <cite>c</cite> has already been found by the first conjunct, and only <cite>b</cite> is the unknown. Right before the execution of the thrid conjunct, all <cite>a,b,c</cite> have been found  so only a check is due.</p>
<p>This analysis requires knowledge of the search behaviour of <cite>div arg1 arg2 arg3 arg4</cite> in the following two cases:</p>
<ul class="simple">
<li>Both <cite>arg1, arg2</cite> are unknowns, but <cite>arg3, arg4</cite> are known.</li>
<li>Only <cite>arg1</cite> is unknown, the other three are known.</li>
</ul>
</div></blockquote>
<ol class="arabic simple">
<li><em>Variant 2</em></li>
</ol>
<blockquote>
<div><div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>gcd a b c &amp;
div a c a’ O &amp;
div b c b’ O
</pre></div>
</div>
<p>Find three unknowns`a,b,c` such  that the relation <cite>gcd a b c</cite> holds, then check that <cite>a</cite> (<cite>b</cite>) is exactly dividable by  <cite>c</cite> with quotient <cite>a’</cite> (resp. <cite>b’</cite>).</p>
<p>Before the first conjunct is executed, all <cite>a,b,c</cite> are  unknown, but by the time the second and third conjuncts are to be executed, the variables <cite>a,b,c</cite> are already computed by the first conjunct, therefore the last two conjuncts merely check the result.</p>
<p>This analysis requires knowledge of the search behaviour of <cite>gcd</cite> when provided  with three free logic variables for its three arguments.</p>
</div></blockquote>
<p>The relevant search behaviours of the sub-relations mentioned in the
table can be observed by running the test file or found in
<a class="reference external" href="answers.txt">answers.txt</a>. For instance, to know the search
behaviour of <code class="docutils literal notranslate"><span class="pre">div</span></code> when only its first and second argument are
unknown, we can make the specific query:</p>
<div class="code ocaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> What divided by what equals 3 with remainder 2 ? (give </span><span class="si">%d</span><span class="s2"> answers) </span><span class="se">\n\n</span><span class="s2">&quot;</span> <span class="n">ans_no</span><span class="p">;</span>
<span class="n">ocrun2</span> <span class="o">~</span><span class="n">n</span><span class="p">:</span><span class="n">ans_no</span> <span class="p">(</span><span class="n">fun</span> <span class="n">q</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">ocanren</span> <span class="p">{</span> <span class="n">div</span> <span class="n">q</span> <span class="n">r</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)))</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">))</span> <span class="p">})</span>
</pre></div>
</div>
<p>The answers are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> What divided by what equals 3 with remainder 2 ? (give 20 answers)

(11, 3)
(14, 4)
(17, 5)
(20, 6)
(23, 7)
(26, 8)
(29, 9)
(32, 10)
(35, 11)
(38, 12)
(41, 13)
(44, 14)
(47, 15)
(50, 16)
(53, 17)
(56, 18)
(59, 19)
(62, 20)
(65, 21)
(68, 22)
</pre></div>
</div>
<p>We could see that the <code class="docutils literal notranslate"><span class="pre">div</span></code> relation is enumerating all possible
divisors in ascending order, starting with the least possible divisor
which is 3 (the divisor must be greater than the remainder 2), together
with the corresponding dividends.</p>
<p>In backward search, therefore, the <code class="docutils literal notranslate"><span class="pre">simplify</span></code> relation first finds a
<code class="docutils literal notranslate"><span class="pre">c</span></code>-multiple of <code class="docutils literal notranslate"><span class="pre">a'</span></code> for some <code class="docutils literal notranslate"><span class="pre">c</span></code>, and then finds a
<code class="docutils literal notranslate"><span class="pre">c</span></code> -multiple
of <code class="docutils literal notranslate"><span class="pre">b'</span></code> for the same <code class="docutils literal notranslate"><span class="pre">c</span></code>. Its check of the gcd relation as the last
step is starighforward if <code class="docutils literal notranslate"><span class="pre">a'/b'</span></code> is already in the simplest form.
Note that the programmer provides <code class="docutils literal notranslate"><span class="pre">a'</span></code> and <code class="docutils literal notranslate"><span class="pre">b'</span></code> so practically
<code class="docutils literal notranslate"><span class="pre">a'/b'</span></code> does not have to be in the simplest form, in which case the
<code class="docutils literal notranslate"><span class="pre">gcd</span></code> check would fail. This all sounds like logical manners to find
integral multiples of a ratio that is in the simplest form. However, the
way in which <code class="docutils literal notranslate"><span class="pre">simplify'</span></code> approaches the problem is firstly guessing an
arbitrary ratio together with the gcd of the numerator and the
denominator, and then it checks if the ratio happens to reduce to
<code class="docutils literal notranslate"><span class="pre">a'/b'</span></code>. This obviously has a bad chance to hit the target. That’s why
<code class="docutils literal notranslate"><span class="pre">simplify</span></code> works better than <code class="docutils literal notranslate"><span class="pre">simplify'</span></code> for backward search, and
they only differ by a swap of conjuncts.</p>
<p>Note worthy is that the advantage of <code class="docutils literal notranslate"><span class="pre">simplify</span></code> over <code class="docutils literal notranslate"><span class="pre">simplify'</span></code> in
backward search is at the cost of some efficiency in forward search,
where <code class="docutils literal notranslate"><span class="pre">simplify'</span></code> smartly finds the gcd of the numerator and the
denominator first and then divides to get the result, but <code class="docutils literal notranslate"><span class="pre">simplify</span></code>
enumerates through all divisors of <code class="docutils literal notranslate"><span class="pre">a</span></code> to find the one that is also a
divisor of <code class="docutils literal notranslate"><span class="pre">b</span></code> and the gcd of <code class="docutils literal notranslate"><span class="pre">a,b</span></code> — less efficient but still
acceptable for small numbers.</p>
<p>As an exercise, the reader could experiment with reordering the
conjuncts so that <code class="docutils literal notranslate"><span class="pre">gcd</span></code> is placed in between the two <code class="docutils literal notranslate"><span class="pre">div</span></code> ’s.
How
would forward and backward search be influenced? A second question: what
will happen and why, if we use <code class="docutils literal notranslate"><span class="pre">simplify</span></code> to find <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, but
give <code class="docutils literal notranslate"><span class="pre">a'</span></code> and <code class="docutils literal notranslate"><span class="pre">b'</span></code> as 4 and 2 respectively, i.e., a ratio not in the
simplest form?</p>
</div>
<div class="section" id="the-trick-of-generate-and-test">
<h2>The Trick of Generate-and-test<a class="headerlink" href="#the-trick-of-generate-and-test" title="Permalink to this headline">¶</a></h2>
<p>When using the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> relation to answer the question: “What and what
have gcd 7 ?”, the distribution of <a class="reference external" href="answers.txt#L432">the answers</a>
does not look balanced: the second number is 7 most of the time, while
the first number is growing. In comparison, <a class="reference external" href="answers.txt#L455">the
answers</a> given by the <code class="docutils literal notranslate"><span class="pre">gcd'</span></code> relation has a more
satisfactory distribution: the first number increases and for each
possible first number, all possible second numbers are enumerated before
the first number is further increased. The <code class="docutils literal notranslate"><span class="pre">gcd'</span></code> relation is defined
using the famous technique known as <em>generate-and-test</em>, which we
explain now.</p>
<p>Browsing the library <a class="reference external" href="peano.ml#L81">source</a> we could see that
<code class="docutils literal notranslate"><span class="pre">gcd'</span></code> is defined in terms of <code class="docutils literal notranslate"><span class="pre">gcd</span></code> together with the addition
relation and the Peano number predicate <code class="docutils literal notranslate"><span class="pre">isp</span></code> (read “is P” or “is a
Peano Number”).</p>
<p>Provided a free variable as the argument, <code class="docutils literal notranslate"><span class="pre">isp</span></code> enumerates all Peano
numbers, in other words, we can obtain the following equation from the
definition of <code class="docutils literal notranslate"><span class="pre">isp</span></code>, where the right hand side is an infinite formula:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">isp</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">==</span> <span class="n">O</span> <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="n">S</span> <span class="n">O</span> <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="p">(</span><span class="n">S</span> <span class="n">O</span><span class="p">))</span> <span class="o">|</span> <span class="o">...</span>
</pre></div>
</div>
<p>Therefore, <code class="docutils literal notranslate"><span class="pre">isp</span></code> could be a Peano number <em>generator</em> .</p>
<p>Moreover, when the third argument of <code class="docutils literal notranslate"><span class="pre">add</span></code> is concrete but the first
and second argument are free variables, the <code class="docutils literal notranslate"><span class="pre">add</span></code> relation can find
all ways to break up the third argument into two addends.</p>
<p>The sequence of <code class="docutils literal notranslate"><span class="pre">isp</span></code> and <code class="docutils literal notranslate"><span class="pre">add</span></code> in the body of <code class="docutils literal notranslate"><span class="pre">gcd'</span></code> can then be
a Peano number pair generator, enumerating all possible pairs of Peano
numbers (in the same way Georg Cantor shows that the set of rational
numbers is enumerable). Now the way <code class="docutils literal notranslate"><span class="pre">gcd'</span></code> works is clear: it
enumerates through (i.e., <em>generates</em>) all possible pairs and then
<em>tests</em> which pairs have the gcd 7. Since the pairs are generated
systematically , the final answers are organized in the way we saw.</p>
<p>Another example of generate-and-test is the <code class="docutils literal notranslate"><span class="pre">simplify</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">a'</span> <span class="pre">b'</span></code>
relation. When <code class="docutils literal notranslate"><span class="pre">a,b</span></code> are given but <code class="docutils literal notranslate"><span class="pre">a',b'</span></code> are left unknown, the
<cite>first ``div`</cite> &lt;peano.ml#L91&gt;`__ generates all possible divisor-quotient
pairs for <code class="docutils literal notranslate"><span class="pre">a</span></code>, and for each such pair the <cite>second
``div`</cite> &lt;peano.ml#L92&gt;`__ tests if the divisor also divides <code class="docutils literal notranslate"><span class="pre">b</span></code> and if
so generates the quotient. The sequence of two <code class="docutils literal notranslate"><span class="pre">div</span></code> ’s then plays
the role of a generator of all common divisors of <code class="docutils literal notranslate"><span class="pre">a,b</span></code> together with
the corresponding pairs of numbers which are <code class="docutils literal notranslate"><span class="pre">a,b</span></code> divided by their
common divisors. The <code class="docutils literal notranslate"><span class="pre">`gcd</span></code> sub-relation <a class="reference external" href="peano.ml#L93">peano.ml#L93</a> finally
checks for the greatest common divisor, and the corresponding pair of
quotients is the answer for <code class="docutils literal notranslate"><span class="pre">a',b'</span></code>.</p>
<p>In summary, generate-and-test is both a technique that the programmer
applies to solve certain problems (e.g., the <code class="docutils literal notranslate"><span class="pre">gcd'</span></code> case), and a usual
way in which relational programs search for answers even if the
programmer does not intentionally apply it (e.g., the <code class="docutils literal notranslate"><span class="pre">simplify</span></code>
case).</p>
</div>
<div class="section" id="the-formula-parser">
<h2>The Formula Parser<a class="headerlink" href="#the-formula-parser" title="Permalink to this headline">¶</a></h2>
<p>In the library implementation and the test file, we often see formulae
enclosed by the <code class="docutils literal notranslate"><span class="pre">ocanren{}</span></code> quotation which takes care of, among
others, precedence and associativity of the logic connectives. It is an
OCanren-specific syntax extension which is described
<a class="reference internal" href="../../camlp5.html#let-ocanren"><span class="std std-ref">OCanren-specific Camlp5 syntax extension</span></a></p>
</div>
<div class="section" id="building-a-library">
<h2>Building a Library<a class="headerlink" href="#building-a-library" title="Permalink to this headline">¶</a></h2>
<p>Being essentially an OCaml library, an OCanren library shall have its
interface <code class="docutils literal notranslate"><span class="pre">.mli</span></code> and implementation <code class="docutils literal notranslate"><span class="pre">.ml</span></code>. The interface typically
contains type definitions (at the four levels), auxiliaries (such as
injection functions, reifiers, etc.) and the relations. Note also the
<code class="docutils literal notranslate"><span class="pre">&#64;type</span></code> syntax in the interface.</p>
<p>Relations shall be systematically tested. This means all possible
combinations of unknown arguments shall be queried wrt. each relation.
The benefits of such systematic test includes reducing surprises when
running the programs, and helping with debugging “bigger” relations that
are defined using smaller relations. For example, understanding the
search behaviour of <code class="docutils literal notranslate"><span class="pre">simplify</span></code> requires knowledge of search behaviours
of <code class="docutils literal notranslate"><span class="pre">div</span></code> and <code class="docutils literal notranslate"><span class="pre">gcd</span></code> and in turn those of <code class="docutils literal notranslate"><span class="pre">lt</span></code>, <code class="docutils literal notranslate"><span class="pre">lte</span></code> and <code class="docutils literal notranslate"><span class="pre">add</span></code>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../aircraft_fleet/README.html" class="btn btn-neutral float-right" title="The Range of a Fleet of Aircraft" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../ascii_ctrl_db/README.html" class="btn btn-neutral float-left" title="A Simple Data Base" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, JetBrains Research

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>