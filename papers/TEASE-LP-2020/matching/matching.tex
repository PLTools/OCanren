\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{TEASE-LP 2020} % Name of the event you are submitting to
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{underscore}           % Only needed if you use pdflatex.

\usepackage{amsmath,amssymb}
%\usepackage[english]{babel}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{comment}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{stmaryrd}
\usepackage{eufrak}
\usepackage{placeins}
\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}{Lemma}
%\newtheorem{corollary}{Corollary}
\newtheorem{hyp}{Hypothesis}
%\newtheorem{definition}{Definition}
\usepackage{caption}
\usepackage{subcaption}
%\usepackage[OT2]{fontenc}   %% Just for lulz

\lstdefinelanguage{minikanren}{
basicstyle=\normalsize,
keywords={fresh},
sensitive=true,
commentstyle=\itshape\ttfamily, % \footnotesize\itshape\ttfamily,
keywordstyle=\textbf,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={fun}{{$\lambda\;\;$}}1 {->}{{$\to$}}3 {===}{{$\,\equiv\,$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {/\\}{{$\wedge$}}2 {\\/}{{$\vee$}}2,
morecomment=[s]{(*}{*)}
}


\lstdefinelanguage{ocaml}{
keywords={fresh, let, begin, end, in, match, type, and, fun, function, try, with, when, class, 
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit, 
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual},
sensitive=true,
basicstyle=\small,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\;\;\to\;\;$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
language=minikanren
}

\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

\def\transarrow{\xrightarrow}
\newcommand{\setarrow}[1]{\def\transarrow{#1}}

\def\padding{\phantom{X}}
\newcommand{\setpadding}[1]{\def\padding{#1}}

\def\subarrow{}
\newcommand{\setsubarrow}[1]{\def\subarrow{#1}}

\newcommand{\trule}[2]{\frac{#1}{#2}}
\newcommand{\crule}[3]{\frac{#1}{#2},\;{#3}}
\newcommand{\withenv}[2]{{#1}\vdash{#2}}
\newcommand{\trans}[3]{{#1}\transarrow{\padding{\textstyle #2}\padding}\subarrow{#3}}
\newcommand{\ctrans}[4]{{#1}\transarrow{\padding#2\padding}\subarrow{#3},\;{#4}}
\newcommand{\llang}[1]{\mbox{\lstinline[mathescape]|#1|}}
\newcommand{\pair}[2]{\inbr{{#1}\mid{#2}}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\highlight}[1]{\color{red}{#1}}
%\newcommand{\ruleno}[1]{\eqno[\scriptsize\textsc{#1}]}
\newcommand{\ruleno}[1]{\mbox{[\textsc{#1}]}}
\newcommand{\rulename}[1]{\textsc{#1}}
\newcommand{\inmath}[1]{\mbox{$#1$}}
\newcommand{\lfp}[1]{fix_{#1}}
\newcommand{\gfp}[1]{Fix_{#1}}
\newcommand{\vsep}{\vspace{-2mm}}
\newcommand{\supp}[1]{\scriptsize{#1}}
\newcommand{\sembr}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cd}[1]{\texttt{#1}}
\newcommand{\free}[1]{\boxed{#1}}
\newcommand{\binds}{\;\mapsto\;}
\newcommand{\dbi}[1]{\mbox{\bf{#1}}}
\newcommand{\sv}[1]{\mbox{\textbf{#1}}}
\newcommand{\bnd}[2]{{#1}\mkern-9mu\binds\mkern-9mu{#2}}
\newcommand{\meta}[1]{{\mathcal{#1}}}
\newcommand{\dom}[1]{\mathtt{dom}\;{#1}}
\newcommand{\primi}[2]{\mathbf{#1}\;{#2}}
\renewcommand{\dom}[1]{\mathcal{D}om\,({#1})}
\newcommand{\ran}[1]{\mathcal{VR}an\,({#1})}
\newcommand{\fv}[1]{\mathcal{FV}\,({#1})}
\newcommand{\tr}[1]{\mathcal{T}r_{#1}}
\newcommand{\diseq}{\not\equiv}
\newcommand{\reprfunset}{\mathcal{R}}
\newcommand{\reprfun}{\mathfrak{f}}
\newcommand{\cstore}{\Omega}
\newcommand{\cstoreinit}{\cstore_\epsilon^{init}}
\newcommand{\csadd}[3]{add(#1, #2 \diseq #3)}  %{#1 + [#2 \diseq #3]}
\newcommand{\csupdate}[2]{update(#1, #2)}  %{#1 \cdot #2}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\ir}{\ensuremath{\mathcal{I\!R}}}

\let\emptyset\varnothing
\let\eps\varepsilon

\title{Compiling Pattern Matching via Relational Programming}
\author{Dmitry Kosarev
\institute{Saint Petersburg State University and \\ JetBrains Research, Russia}
\email{Dmitrii.Kosarev@protonmail.ch}
\and
Dmitry Boulytchev
\institute{Saint Petersburg State University and \\ JetBrains Research, Russia}
\email{dboulytchev@math.spbu.ru}
}
\def\titlerunning{TODO}
\def\authorrunning{D. Kosarev \& D. Boulytchev}
\begin{document}
\maketitle

Real world modern compilers are obliged to address a few problems which are NP-complete and hence can't have effective  algorithm to solve them. So, compilers use semi-optimal algorithms to find a decent solution. Optimal algorithms require brute force search to get the best solution and  affect compilation speed negatively. In this work we apply relational programming -- a convenient DSL for implementing search -- to compilation of pattern matching, one of a kind hard problems for compiler.

The task of compiling pattern matching for typed languages is well presented in literature~\cite{maranget2001,maranget2008}.




We test approach on simplified source language $PM$ where scrutinee is a value $\in\mathcal{V}$ of algebraic data type, only wildcards and nested constructors are allowed as patterns $\mathcal{P}$ and right hand side of clause is its index. The source language is easy extendable by pattern variables and optional pattern guards that test subterms of scrutinee using a function. The semantics of $PM$ is a function from concrete scrutinee $s$, concrete patterns $pats$ and concrete guards $gs$ to clause indexes, and is denoted as $\sem{s,pats,gs}_{PM} = i$.

Compilation scheme translates sentences from $PM$ to $\ir$ language which has constructions for clause indexes and conditions which test matchable values for specific constructor. Matchable values can be either a scrutinee, or a projection of matchable value that returns one of its field indexed by natural numbers. $\ir$ language is easy extendable by tests for fixed number of pattern guards. The semantics is straightforward and is denoted by $\sem{\cdot}_{\ir}$.

We deal with a task of compiling pattern matching as it is a synthesis problem. The goal of algorithm is to synthesize $ideal_\ir$ for concrete patterns $pats$ and guards that, firstly, will behave the same as original pattern matching for any possible scrutinee $s$. Secondly, we want shortest solution because short code usually runs faster. Relational programming~\cite{OCanren} will help with that because it has a tendency to generate short answers earlier, although this tendency is not strict.

$$
\forall s:\; \sem{s; ideal_\ir}_\ir = \sem{s;pats}_{PM}
$$

To eliminate universal quantifier we use the following observation: for \emph{finite} amount of patterns of \emph{finite} height we can generate \emph{finite} amount of examples to test pattern matching semantics. In examples, very deep subterms can have any value because they will not be tested during pattern matching. We can reformulate synthesis problem as follows:

$$
\mid  Examples\mid < \infty\quad \land\quad \left(\forall e \; (e\in Examples)\quad\land \quad\left( \sem{e; ideal_\ir}_\ir = \sem{e;pats}_{PM}\right)\right)
$$

For plain ADT the approach will generate required examples in finite time, but for GADTs it can diverge because inhabitancy problem is semi-decidable~\cite{garrigue2017gadts}(chapter 5). Inhabitants generation as well as synthesis algorithm is implemented\footnote{\url{https://github.com/Kakadu/pat-match/}} using relational programming.

Presented approach is good as general description of an idea but require a few tweaks to start working, for example, on presented sample~\ref{fig:example1} . Firstly, synthesis procedure in a way as it is described doesn't take types into account, so it is useful to give hints about which parts of scrutinee should be checked for which constructors. Second observation says that we run $\sem{\cdot}_\ir$ in concrete direction, so it is possible to check periodically count of \texttt{IfTag} constructors in result value and prune branches where it becomes too big. Thirdly, synthesis query generates a lot of similar queries, and we use tabling to speedup search. All three observations are important, removing one of them leads to visible performance degradation.

The optimal (two \texttt{IfTag}'s) and the semi-optimal solution (three \texttt{IfTag}'s) for~\ref{fig:example1} are described in~\cite{maranget2008}. Current implementation generates semi-optimal solution as 28th answer. Before that it generates optimal solution (and it's equivalents) three times, other 24 answers are longer and less useful. All tasks (example generation, synthesis and printing answers) take 3 seconds, which is unfortunate.

Shortly, we present following contributions
\begin{itemize}
\item Code synthesis for pattern matching works after implementing \emph{three optimizations} above.
\item GADTs, pattern binding and guards works for simple examples, the approach is easy extendable by them.
\end{itemize}

Future work is
\begin{itemize}
\item Discover other optimizations and enable current ones automatically using type information (at the moment we patched synthesis algorithm manually for concrete example).
\item When current implementation tests for \texttt{cons} tag it can't propagate constraint that tag equals to \texttt{nil} to the \texttt{else} branch, which partially explains why branch pruning is so useful.
\item Algorithm for inhabitant generation requires proper formulation and proof.
\item Apply current synthesis procedure for exhaustiveness checking which will give us \emph{single} procedure for compilation and exhaustiveness checking.
\item Test the approach on real world problems (embedding to OCaml compiler).
\end{itemize}


\begin{figure}
\centering
\begin{minipage}{.7\textwidth}
  \centering
\begin{align*}
\mathcal{C} =&\; \{ C_1^{k_1}, \dots, C_n^{k_n} \} \\
\mathcal{V} =&\;  \mathcal{C}\ \mathcal{V}^*\\
\mathcal{M} =&\;  \mathcal{S} \\
          \mid\; &\; \text{\texttt{Field}}\;  \mathcal{M}\times  \mathbb{N}\\
\mathcal{P} =&\;  \text{\texttt{Wildcard}} \\
          \mid\; &\; \text{\texttt{Var}}\  Name\\
          \mid\; &\; \text{\texttt{PConstructor}}\  \mathcal{C}\times  \mathcal{P}^*\\
\ir  =&\; \text{\texttt{Int}}\  \mathbb{N} \\
%           \mid\; &\;\mathcal{S} \\
           \mid\; &\; \text{\texttt{IfTag}}\; \mathcal{C}\times \mathcal{M}\times \ir\times \ir\\
           \mid\; &\; \text{\texttt{IfGuard}}\ \mathbb{N}\times (Name\times \mathcal{M})^*\times \ir\times \ir\\
Clause =&\;  \mathcal{P} \times \mathbb{N}? \times \ir
\end{align*}
  \captionof{figure}{Structure of $PM$ and \ir languages}
%  \label{fig:test1}
\end{minipage}%
\begin{minipage}{.3\textwidth}
  \centering
\begin{lstlisting}[language=ocaml]
match s with 
| ([], _)     -> 1
| (_, [])     -> 2
| (_::_,_::_) -> 3
\end{lstlisting}
  \captionof{figure}{Simple example of pattern matching problem from~\cite{maranget2008}}
\label{fig:example1}
\end{minipage}
\end{figure}

%\nocite{*}
\bibliographystyle{eptcs}
\bibliography{matching}

\end{document}
