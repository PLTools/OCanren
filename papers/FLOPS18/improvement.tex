\section{Search Improvement}
\label{improvement}

As we've seen in the previous section, the non-commutativity of conjunction is one of the reasons for
refutational incompleteness (the other one is recursion). Switching arguments of a certain conjunction
can sometimes improve the results; there is, however, no certain static order,
beneficial in all cases. Thus, we can make the following observations:

\begin{itemize}
\item the conjunction to change has to be properly identified;
\item the order of conjuncts has to be a subject of a \emph{dynamic} choice.
\end{itemize}

Our improvement of the search is based on the idea of switching the order of conjuncts only when
the divergence of the first one is detected. More specifically: 

\begin{itemize}
\item during the search, we keep the track of all conjunctions being performed;
\item when we detect the divergence, we roll back to the nearest conjunction, for which 
we did not try all orders of constituents yet, switch its constituents, and rerun 
the search from that conjunction.
\end{itemize}

The important detail is the divergence test. Of course, due to the fundamental results in computability
theory, there is no hope to find a \emph{precise} computable test, which constitutes the necessary and 
sufficient condition of divergence. However, in our case a sufficient condition is sufficient. Indeed,  
a sufficient condition identifies a case, when the search, being continued, will lead to an incompleteness 
(since a divergence in our semantics always means incompleteness). Thus, it is no harm to try some other way. 

Our divergence test is based on the following notion:

\begin{definition}
\normalfont 
We say, that a vector of terms $\overline{a^{\phantom{x}}_i}$ is more general, than a vector of terms $\overline{b^{\phantom{x}}_i}$ (notation 
$\overline{a^{\phantom{x}}_i}\succeq\overline{b^{\phantom{x}}_i}$), if there is a substitution $\tau$, such that for $\forall i\;b_i = a_i \tau$.
\end{definition}

The idea of the divergence test is rather simple: it identifies a recursive call with more general arguments 
than (some) enclosing one. In the Appendix~\ref{appendix} we provide a formal proof, that, indeed,
this test constitutes a sufficient condition for divergence.

An efficient reordering of the conjuncts also requires a special treatment. First, we have to represent immediately nested conjunctions in a 
uniform way: indeed, simply switching any two operands of, for example, \mbox{$(g_1\wedge g_2)\wedge g_3$}, would not 
allow us to try \mbox{$(g_1\wedge g_3)\wedge g_2$}. Thus, we have to flatten each ``cluster'' of nested conjunctions into a list of conjuncts\mbox{$\bigwedge g_i$}, 
where none of the goals $g_i$ is a conjunction. Then, it may seem at the first glance, that the number of orderings to try 
is exponential on the number of conjuncts; we are going to show, that, fortunately, this is not the case. 

Indeed, consider a diverging conjunction \mbox{$g_1\wedge g_2\wedge g_3$}, and assume, that \mbox{$g_1\wedge g_2$} converges. 
Does it make any sense to switch the first two conjuncts? Obviously, \mbox{$g_2\wedge g_1$} either diverges, or converges with the same 
result as \mbox{$g_1\wedge g_2$} (up to the renaming of semantic variables). Anyway, switching the first two conjuncts is
unnecessary. This observation can be easily generalized: if we have a converging prefix $\omega$ in a list of conjuncts $\omega\rho$, making
any permutations inside $\omega$ is pointless.

Next, suppose we already have a list of conjuncts \mbox{$\omega\dots g_1\dots g_2\dots$}, where $\omega$ is a converging prefix, and
$g_1$ and $g_2$~--- two goals, which, being placed immediately after $\omega$, converge (if there are no such
goals, the whole list, obviously, diverges). Do we need to try both cases ($g_1$ or $g_2$ immediately after $\omega$)? 
It is rather easy to see, that \mbox{$\omega g_1$} delivers no less information, that \mbox{$\omega$}; since
$g_2$ converges immediately after $\omega$, it will converge after \mbox{$\omega g_1$}. Thus, we may apply a greedy approach: each
time we have a converging prefix of conjuncts (possibly empty), and some tail. We try to put each conjunct from the tail 
immediately after the prefix. If we find a converging conjunct, we attach it to the prefix and continue; if no, then the list of 
conjuncts diverges. Thus, we can find a converging order (if any) in a quadratic time.

% (Lemma~\ref{three} from Appendix~\ref{appendix}
%can be used to justify this claim). Thus, we do not to try two cases.


\begin{comment}
First, we need a way to detect 
a situation, when we give up on current conjunction and proceed to the next enclosing one (if any).
We represent a cluster of nested conjunctions as a state \mbox{$([p_i], n, [s_i])$}, where $[p_i]$, $[s_i]$ are lists of
non-conjunction goals, $n$~--- some natural number. We call $[p_i]$ a prefix, $[s_i]$~--- a suffix, and $n$~--- a position. 
Initially, the prefix is empty, $n=0$, and the suffix consists of the list of all conjuncts.

Let \mbox{$[p_i], n, [s_1,\dots]$} be a state; we try to evaluate $s_1$. There are three possible outcomes:

\begin{enumerate}
\item The evaluation converges; then we change the state into \mbox{$[p_i,s_1], 0, [s_2\dots]$} and continue.
\item The evaluation ends with a signal, that a divergence was detected inside the evaluation of $s_1$. We
change the state into \mbox{$[p_i], n+1, [s_{n+1},\dots,s_n=s_1,\dots]$} (in other words, we switch $s_1$ with 
$s_{n+1}$).
\item The evaluation diverges without detectiong. Nothing can be done in this case.
\end{enumerate}



We also need to pay a special attention to make it possible to enumerate all orders of all conjuncts in
compound conjunctions, not only immediate ones; thus, in \mbox{$(g_1\wedge g_2)\wedge g_3$} we should
be able to try not only \mbox{$(g_1\wedge g_2)\wedge g_3$} and \mbox{$g_3 \wedge(g_1\wedge g_2)$}, but, 
for example, \mbox{$(g_2\wedge g_1)\wedge g_3$}, etc. It can be easily achieved by flattening all nested
conjunctions to a \emph{cluster} $\bigwedge g_i$, where none of $g_i$ is a conjunction. 

In may seem at a first glance, that in the worst case an exponential number of conjunct orders have to
be tried. This is, actually, not true, because we do not need to try different orders in the
converging prefix of conjuncts. We present the following discipline of reordering:

\begin{itemize}
\item We associate a natural number $n$ with each cluster of conjuncts; initially this
number is $0$. Informally, the non-zero value $k$ says, that we reordered the cluster by
putting $k$-th conjuncts in the first place.
\item    
\end{itemize}



Moreover, all orders tried so far, have to be memorized. When we tried out every one, we need to 
proceed to the next enclosing conjunction (if any). Note, in this approach we modify the conjunctions 
according to their dynamic evaluation order, not static scoping. 


Now it is sufficient to present a query, which is not refutationally complete w.r.t. to the semantics, 
but becomes refutationally complete w.r.t. to the improvement. For such query we can take 
\mbox{\lstinline|fresh ($p\;q$) (append$^o\;p\;q\;$ Nil)|}~--- indeed, from Section~\ref{incompleteness} we
already know, that it diverges. We also remember that the reason of the divergence is the infinite
sequence of recursive calls with renamed arguments~--- but this means, that the divergence test is satisfied.
Finally, switching the recursive call to \lstinline|append$^o$| with the preceding conjunct makes the query converge~--- this is exactly, what the improvement does.
\end{comment}