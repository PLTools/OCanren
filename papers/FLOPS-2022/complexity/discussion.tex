\section{Discussion}
\label{sec:discussion}

\begin{comment}
In this paper we analyse only complexity of the scheduling of unifications, ignoring complexity of performing these unifications.
However, we argue that the scheduling factor we calculate can be used as an approximation for the whole program execution complexity
in most practical cases. This is not unusual: it is common knowledge among users of \textsc{Prolog} that in practise almost always each
unification takes constant time (depending on the input), some theoretical basis for this is given in~\cite{UnificationAverageCost}.
Therefore it is conventional for complexity analyses of \textsc{Prolog} to use the number of unifications or the number of resolution
steps (which are assymptotically equivalent) as the time measure.

There are some specifics of unification implementation in \mK. First, for simple backtracking in a non-mutable fashion the triangular
substitutions~\cite{UnificationTheory} are used instead of the usual indempotent ones. It brings additional overhead that is analysed
in some detail in~\cite{WillsTheisis}, but experience shows that in most practical cases this overhead in insignificant (for this reason
the simplest implementations with bad worst-time complexity are kept). Secondly, \mK allows programmer to chose whether to perform occurs
checks in a specific unification, and by default they are performed, which this time adds significant overhead usually changing the
resulting complexity. These checks are rarely violated (in the context of \textsc{Prolog} this is established in~\cite{OccursChecksRevisited}),
so in other languages (like \textsc{Prolog}) the occurs checks are usually ommited by default. Sheduling factor we compute can be used as a
measure for time in \mK only if occurs checks are ommited.
\end{comment}

Our approach imposes three conditions on the analyzed programs: disjunctive normal form, uniqueness of answers and grounding of relational calls.
The first two are rather non-restrictive: DNF is equivalent to the description of relation as a set of Horn clauses in \textsc{Prolog},
and the majority of well-known examples in \mK are written in this or very similar form. Repetitive answers are usually an indication
of mistake in a program~\cite{WillsThesis}. The groundness condition is more serious: it prohibits program execution from presenting infinitely
many individual ground solutions in one answer using free variables, which is a useful pattern. At the same time, this requirement is
not unique to our work (the framework for \textsc{CASLOG} system mentioned above imposes exactly the same condition) and the experience
shows that many important kinds of programs satisfy it (although it is hard to characterize the class of such programs precisely).
Relaxing of any of these restriction will likely mess up the current relatively compact desrciption of symbolic execution (for
the conditions on relational calls) or the form of the extracted inequalities (for the DNF condition).

Also, for now we confine ourselves to the problem of estimating the time of the full search for a given query. Estimating the time before
the first (or some specific) answer is believed to be an important and probably more practical task. Unfortunately, the technique we describe
can not be easily adjusted for this case. The reason for this is that the reasoning about time (scheduling time in particular) in our
terms becomes non-compositional for the case of interrupted search: if the answer is found in some branch, the search is cut short in
other branches too. And we still need to analyse every branch, since the height of states can be different in different branches, so
the equal number of semantic steps in different branches can take different amounts of time to evaluate. This picture requires more
complicated notions with non-trivial dependencies between them and the model becomes impractical. We still can use our technique
to establish some rouugh lower and upper bounds (for example via relation between two complexity factors from \lemmaword~\ref{lem:lem:d_t_relation}),
but in general this problem requires a separate thorough analysis,

