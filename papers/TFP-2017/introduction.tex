\section{Introduction}
\label{intro}

Relational programming is an attractive technique, based on the idea of constructing programs as relations.
While in general some relational effects can be reproduced with a number of languages for logic programming, such as
Prolog, Mercury\footnote{\url{https://mercurylang.org}}, or Curry\footnote{\url{http://www-ps.informatik.uni-kiel.de/currywiki}}, in
a narrow sense relational programming amounts to writing relational specifications in \miniKanren~\cite{TRS}. \miniKanren\footnote{\url{http://minikanren.org}},
initially designed as a small relational DSL, embedded in Scheme/Racket, was later implemented for a number of general-purpose host languages,
including Scala, Haskell, Standard ML and OCaml.

With the relational approach, it becomes possible to give simple and elegant solutions for the problems, otherwise
considered as tricky, tough, tedious, or boring~\cite{unified}. For example, relational interpreters can be used to derive
\emph{quines}~--- programs, which reduce to itself, as well as \emph{twines} or \emph{thrines} (pairs or triples of
programs, reducing to each other)~\cite{Untagged}; a straightforward relational description of
simply typed lambda calculus~\cite{Lambda} inference rules works both as type inferencer and inhabitation problem solver~\cite{WillThesis};
relational list sorting can be used to generate all permutations~\cite{ocanren}, etc. 

On the other hand, writing relational specifications can sometimes be a tricky and error-prone task. Fortunately, many 
specifications can be written systematically by ``generalizing'' a certain functional program. From the very beginning, 
the conversion from functional to relational form was considered as an element of relational programming thesaurus~\cite{TRS}. However,
the traditional approach~--- \emph{unnesting}~--- was formulated for an untyped case, worked only for specifically written
programs and was never implemented.

We present a generalized form of relational conversion, which can be applied to typed terms in general form. We study the relational conversion 
for a small ML-like language (essentially, a certain subset of OCaml), equipped with Hindley-Milner type system with let-polymorphism~\cite{Types}. 
We start from retelling the syntax, typing rules, and operational semantics, and then extend the source language with a conventional set of 
relational constructs. This set corresponds to existing typed embedding of \miniKanren into OCaml~\cite{ocanren}. We then present typing rules and 
develop operational semantics for this relational extension; to our knowledge, this is the first attempt to specify formal semantics for
\miniKanren. Next, we develop formal rules for relational conversion and prove, that these rules respect both typing and
semantics. Finally, we describe the implementation of a relational converter and demonstrate its application for a number of problems, for some
of which we present a relational solution for the first time.
